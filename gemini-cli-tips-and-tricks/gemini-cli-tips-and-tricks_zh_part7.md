## 技巧 11：無頭模式和腳本模式（在背景中運行 GEMINI CLI）

**快速用例：** 您可以透過在無頭模式下運行 Gemini CLI，在腳本或自動化中使用它。這意味著您透過命令列參數或環境變數提供提示（甚至完整的對話），Gemini CLI 會產生輸出並退出。這對於與其他工具整合或按計畫觸發 AI 任務非常有用。

例如，要獲得一次性答案而無需開啟 REPL，您已經看到可以使用 `gemini -p “...prompt...”`。這已經是無頭用法：它會列印模型的響應並返回到 shell。但您可以做更多：

*   **系統提示覆蓋：** 如果您想使用自訂系統角色或指令集（與預設不同）運行 Gemini CLI，您可以使用環境變數 `GEMINI_SYSTEM_MD`。透過設定此變數，您告訴 Gemini CLI 忽略其內建系統提示並改用您提供的檔案。例如：

    ```pwsh
    $env:GEMINI_SYSTEM_MD=”/path/to/custom_system.md”
    gemini -p “謹慎執行任務 X”
    ```

    這將在執行提示之前將您的 `custom_system.md` 載入為系統提示（AI 遵循的「角色」和規則）。或者，如果您設定 `GEMINI_SYSTEM_MD=true`，CLI 將在目前專案的 `.gemini` 目錄中尋找名為 `system.md` 的檔案。此功能非常高級——它本質上允許您用自己的指令替換 CLI 的內建大腦，一些用戶會為專業工作流程（例如模擬特定角色或強制執行超嚴格策略）執行此操作。請謹慎使用，因為替換核心提示可能會影響工具使用（核心提示包含有關 AI 如何選擇和使用工具的重要指示）。
*   **透過 CLI 直接提示：** 除了 `-p` 之外，還有 `-i`（互動式提示），它會以初始提示啟動會話，然後保持開啟。例如：`gemini -i “你好，讓我們偵錯一些東西”` 將開啟 REPL 並已經向模型打招呼。這在您希望在啟動時立即提出第一個問題時很有用。
*   **使用 shell 管道編寫腳本：** 您不僅可以將文字，還可以將檔案或命令輸出管道傳輸到 Gemini。例如：`gemini -p “總結此日誌：” < big_log.txt` 將 `big_log.txt` 的內容輸入到提示中（在「總結此日誌：」之後）。或者您可以執行 `some_command | gemini -p “根據上述輸出，出了什麼問題？”`。此技術允許您將 Unix 工具與 AI 分析結合。它在單次操作的意義上是無頭的。
*   **在 CI/CD 中運行：** 您可以將 Gemini CLI 整合到建置流程中。例如，CI 管道可能會運行測試，然後使用 Gemini CLI 自動分析失敗的測試輸出並發布評論。使用 `-p` 標誌和環境身份驗證，可以編寫此腳本。（當然，請確保環境具有所需的 API 金鑰或身份驗證。）

還有一個無頭技巧：`--format=json` 標誌（或配置設定）。如果您配置它，Gemini CLI 可以以 JSON 格式輸出響應，而不是人類可讀的文字。這對於程式化消費很有用——您的腳本可以解析 JSON 以獲取答案或任何工具操作詳細資訊。

**為什麼無頭模式很重要：** 它將 Gemini CLI 從互動式助理轉變為其他程式可以調用的後端服務或實用程式。您可以安排一個 cronjob，每晚運行 Gemini CLI 提示（想像一下使用 AI 邏輯生成報告或清理某些東西）。您可以在 IDE 中連接一個按鈕，觸發無頭 Gemini 運行以執行特定任務。

**範例：** 假設您想要一個新聞網站的每日摘要。您可以有一個腳本：

```pwsh
gemini -p “Web-fetch \”https://news.site/top-stories\” 並提取標題，然後將它們寫入 headlines.txt”
```

可能帶有 `--yolo`，這樣它就不會要求確認寫入檔案。這將使用網路擷取工具獲取頁面，並使用檔案寫入工具儲存標題。所有這些都是自動的，無需人工干預。一旦您將 Gemini CLI 視為可編寫腳本的組件，可能性就無窮無盡。

總之，無頭模式實現了自動化。它是 Gemini CLI 與其他系統之間的橋樑。掌握它意味著您可以擴展您的 AI 使用——不僅僅是在您在終端機中輸入時，即使您不在，您的 AI 代理也可以為您工作。

（提示：對於真正長時間運行的非互動式任務，您可能還會查看 Gemini CLI 的「計畫」模式，或者它如何在沒有干預的情況下生成多步驟計畫。但是，這些是超出此範圍的高級主題。在大多數情況下，透過無頭模式精心製作的單個提示可以實現很多。）

## 技巧 12：儲存和恢復聊天會話

**快速用例：** 如果您已經使用 Gemini CLI 偵錯了一個小時的問題，並且需要停止，您不必丟失對話上下文。使用 `/chat save <name>` 儲存會話。稍後（即使在重新啟動 CLI 之後），您可以使用 `/chat resume <name>` 從上次離開的地方繼續。這樣，長時間運行的對話可以無縫地暫停和繼續。

Gemini CLI 本質上內建了一個聊天會話管理器。需要了解的命令是：

*   `/chat save <tag>` - 在您提供的標籤/名稱下儲存目前的對話狀態。標籤就像該會話的檔案名或金鑰。如果您願意，請經常儲存，如果標籤存在，它將覆蓋它。（使用描述性名稱很有幫助——例如，`chat save fix-docker-issue`。）
*   `/chat list` - 列出您所有已儲存的會話（您已使用的標籤）。這有助於您記住您之前儲存的名稱。
*   `/chat resume <tag>` - 恢復具有該標籤的會話，將整個對話上下文和歷史記錄恢復到儲存時的狀態。這就像您從未離開過一樣。然後您可以從該點繼續聊天。
*   `/chat share` - （儲存到檔案）這很有用，因為您可以與其他人共享整個聊天，其他人可以繼續會話。幾乎是協作式的。

在底層，這些會話很可能儲存在 `~/.gemini/chats/` 或類似位置。它們包括對話訊息和任何相關狀態。此功能對於以下情況非常有用：

*   **長時間偵錯會話：** 有時使用 AI 偵錯可能是一個漫長的來回過程。如果您無法一次性解決，請儲存它並稍後回來（也許帶著清醒的頭腦）。AI 仍然會「記住」之前的一切，因為整個上下文都會重新載入。
*   **多日任務：** 如果您將 Gemini CLI 用作專案的助理，您可能有一個「重構模組 X」的聊天會話，該會話持續多天。您可以每天恢復該特定聊天，這樣上下文就不會每天重置。同時，您可能還有一個單獨儲存的「編寫文件」會話。切換上下文只是儲存一個並恢復另一個的問題。
*   **團隊交接：** 這更具實驗性，但理論上，您可以與同事共享已儲存聊天的內容（儲存的檔案很可能可攜式）。如果他們將其放入其 `.gemini` 目錄並恢復，他們可以看到相同的上下文。協作的實際更簡單方法只是從日誌中複製相關的問答，並使用共享的 `GEMINI.md` 或提示，但值得注意的是，會話資料歸您所有。

**使用範例：**

```sh
/chat save api-upgrade
```

（會話已儲存為「api-upgrade」）

```sh
/quit
```

（稍後，重新開啟 CLI）

```pwsh
PS D:\> gemini
gemini> /chat list
```

（顯示：api-upgrade）

```sh
gemini> /chat resume api-upgrade
```

現在模型會以上次交換的狀態準備好迎接您。您可以透過向上捲動來確認您之前的所有訊息都存在。

**專業技巧：** 儲存聊天時使用有意義的標籤。不要使用 `/chat save session1`，而是給它一個與主題相關的名稱（例如 `/chat save memory-leak-bug`）。這將有助於您稍後透過 `/chat list` 找到正確的標籤。沒有宣布可以儲存多少個會話的嚴格限制，但偶爾清理舊會話可能是一個明智的組織方式。

此功能將 Gemini CLI 轉變為持久的顧問。您不會丟失在對話中獲得的知識；您可以隨時暫停和恢復。與其他一些在關閉時忘記上下文的 AI 介面相比，這是一個區別。對於高級用戶來說，這意味著您可以與 AI 維護並行工作線程。就像您為不同任務開啟多個終端機選項卡一樣，您可以儲存多個聊天會話並在任何給定時間恢復您需要的會話。
