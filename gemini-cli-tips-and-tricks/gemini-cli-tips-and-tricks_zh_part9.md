## 技巧 15：壓縮長對話以保持在上下文內

**快速用例：** 如果您與 Gemini CLI 聊天了很長時間，您可能會達到模型的上下文長度限制，或者只是發現會話變得難以管理。使用 `/compress` 命令總結到目前為止的對話，用簡潔的摘要替換完整的歷史記錄。這可以騰出空間進行更多討論，而無需從頭開始。

大型語言模型具有固定的上下文視窗（Gemini 2.5 Pro 的視窗非常大，但不是無限的）。如果您超出它，模型可能會開始忘記較早的訊息或失去連貫性。`/compress` 功能本質上是您會話的 AI 生成的 tl;dr，它保留了重要點。

**工作原理：** 當您輸入 `/compress` 時，Gemini CLI 將擷取整個對話（系統上下文除外）並產生摘要。然後它將聊天歷史記錄替換為該摘要作為單個系統或助理訊息，保留基本細節但刪除逐分鐘的對話。它將指示壓縮已發生。例如，在 `/compress` 之後，您可能會看到類似以下內容：

```
--- 對話已壓縮 ---
討論摘要：用戶和助理一直在偵錯應用程式中的記憶體洩漏。關鍵點：問題可能出在 DataProcessor.js 中，其中物件未被釋放。助理建議新增日誌記錄並識別出可能的無限迴圈。用戶即將測試修復。
--- 摘要結束 ---
```

從那時起，模型只有該摘要（加上新訊息）作為之前發生的事情的上下文。如果摘要捕獲了相關資訊，這通常就足夠了。

**何時壓縮：** 理想情況下，在您達到限制之前。如果您注意到會話變得冗長（數百個回合或上下文中有大量程式碼），請主動壓縮。備忘單提到自動壓縮設定（例如，當上下文超過最大值的 60% 時壓縮）。如果您啟用該設定，Gemini 可能會自動壓縮並通知您。否則，手動 `/compress` 是您的工具包中的一個選項。

**壓縮後：** 您可以正常繼續對話。如果需要，您可以在非常長的會話中多次壓縮。每次壓縮都會失去一些粒度，因此不要無緣無故地過於頻繁地壓縮——您可能會對複雜的討論產生過於簡短的記憶。但通常模型的自身摘要在保留關鍵事實方面做得很好（您也可以隨時自己重述任何關鍵內容）。

**上下文視窗範例：** 讓我們說明一下。假設您透過引用許多檔案輸入了一個大型程式碼庫，並且有一個 1M token 的上下文（最大值）。如果您隨後想轉移到專案的不同部分，而不是開始一個新會話（失去所有這些理解），您可以壓縮。摘要將濃縮從程式碼中獲得的知識（例如「我們載入了模組 A、B、C。A 具有這些函數... B 以這些方式與 C 互動...」）。現在您可以繼續詢問新事物，並抽象地保留這些知識。

**記憶體與壓縮：** 請注意，壓縮不會儲存到長期記憶體中，它僅限於對話。如果您有永遠不想丟失的事實，請考慮技巧 4（新增到 `/memory`）——因為記憶體條目將在壓縮後倖存下來（它們無論如何都會被重新插入，因為它們在 `GEMINI.md` 上下文中）。壓縮更多是關於臨時聊天內容。

一個小小的警告：壓縮後，AI 的風格可能會略有改變，因為它實際上看到的是一個帶有摘要的「全新」對話。它可能會重新介紹自己或改變語氣。您可以指示它「從這裡繼續...（我們已壓縮）」以使其順暢。實際上，它通常會繼續得很好。

總之（雙關語），當您的會話變長時，請使用 `/compress` 以保持效能和相關性。它有助於 Gemini CLI 專注於大局，而不是對話歷史記錄的每個細節。這樣，您可以進行馬拉松式的偵錯會話或廣泛的設計討論，而不會耗盡 AI 正在書寫的「心智紙」。

## 技巧 16：使用 ! 傳遞 Shell 命令（與您的終端機對話）

**快速用例：** 在 Gemini CLI 會話中的任何時候，您都可以透過在命令前加上 `!` 來運行實際的 shell 命令。例如，如果您想檢查 git 狀態，只需輸入 `!git status`，它就會在您的終端機中執行。這可以讓您免於切換視窗或上下文——您仍然在 Gemini CLI 中，但您本質上是在告訴它「讓我快速運行這個命令」。

此技巧是關於 Gemini CLI 中的 Shell 模式。有兩種使用方式：

*   **單一命令：** 只需在提示符開頭加上 `!`，然後是任何命令和參數。這將在目前工作目錄中執行該命令，並在行內顯示輸出。例如：

    ```pwsh
    !ls -lh src/
    ```

    將列出 `src` 目錄中的檔案，輸出類似於您在普通終端機中看到的內容。輸出後，Gemini 提示符會返回，以便您可以繼續聊天或發出更多命令。
*   **持久 shell 模式：** 如果您單獨輸入 `!` 並按下 Enter，Gemini CLI 將切換到子模式，您將獲得一個 shell 提示符（通常看起來像 `shell>` 或類似）。現在您可以互動式地輸入多個 shell 命令。它本質上是 CLI 中的一個迷你 shell。您可以透過在空行上再次輸入 `!`（或 `exit`）來退出此模式。例如：

    ```pwsh
    !
    shell> pwd
    /home/alice/project
    shell> python --version
    Python 3.x.x
    shell> !
    ```

    在最後一個 `!` 之後，您將返回到正常的 Gemini 提示符。

**為什麼這很有用？** 因為開發是動作和查詢的混合。您可能正在與 AI 討論某些事情，並意識到您需要編譯程式碼或運行測試才能看到某些內容。與其離開對話，您可以快速完成並將結果反饋到聊天中。事實上，Gemini CLI 通常會為您執行此操作，作為其工具使用的一部分（例如，當您要求修復測試時，它可能會自動運行 `!pytest`）。但作為用戶，您也可以完全控制手動執行此操作。

**範例：**

*   在 Gemini 建議程式碼修復後，您可以執行 `!npm run build` 以查看它是否編譯，然後複製任何錯誤並要求 Gemini 協助解決這些錯誤。
*   如果您想在 `vim` 或 `nano` 中開啟檔案，您甚至可以透過 `!nano filename` 啟動它（儘管請注意，由於 Gemini CLI 有自己的介面，在其中使用互動式編輯器可能會有點尷尬——最好使用內建編輯器整合或複製到您的編輯器）。
*   您可以使用 shell 命令為 AI 收集資訊：例如，`!grep TODO -R .` 以查找專案中的所有 TODO，然後您可以要求 Gemini 協助解決這些 TODO。
*   或者只是將其用於環境任務：如果需要，`!pip install some-package` 等，而無需離開 CLI。

**無縫互動：** 一個很酷的方面是對話如何引用輸出。例如，您可以執行 `!curl http://example.com` 以擷取一些資料，查看輸出，然後立即對 Gemini 說：「將上述輸出格式化為 JSON」——由於輸出已列印在聊天中，AI 在上下文中可以處理它（前提是它不會太大）。

**終端機作為預設 shell：** 如果您發現自己總是將命令加上 `!` 字首，您實際上可以預設使 shell 模式持久。一種方法是使用特定的工具模式啟動 Gemini CLI（有一個預設工具的概念）。但更簡單的方法是：如果您計畫運行大量手動命令並且偶爾才與 AI 對話，則在會話開始時直接進入 shell 模式（不帶任何內容的 `!`）。然後，您可以在需要提問時隨時退出 shell 模式。這幾乎就像將 Gemini CLI 變成您的普通終端機，而該終端機恰好有一個隨時可用的 AI。

**與 AI 規劃整合：** 有時 Gemini CLI 本身會建議運行 shell 命令。如果您批准，它實際上與 `!command` 相同。了解這一點，您就知道您始終可以介入。如果 Gemini 卡住了，或者您想嘗試某些東西，您不必等待它建議——您可以直接執行，然後繼續。

總之，`!` 傳遞意味著您無需離開 Gemini CLI 即可執行 shell 任務。它消除了與 AI 聊天和在系統上執行命令之間的界限。作為專業用戶，這對於效率來說非常棒——您的 AI 和您的終端機成為一個連續的環境。
