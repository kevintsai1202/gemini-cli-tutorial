## 技巧 7：使用 @ 引用檔案和圖像以獲得明確上下文

**快速用例：** 與其口頭描述檔案內容或圖像，不如直接將 Gemini CLI 指向它。使用 `@` 語法，您可以將檔案、目錄或圖像附加到您的提示中。這保證 AI 能夠準確地看到這些檔案中的內容作為上下文。例如：

```
向我解釋這段程式碼：@./src/main.js
```

這將在提示中包含 `src/main.js` 的內容（最多達到 Gemini 的上下文大小限制），以便 AI 可以讀取並解釋它。

這個 `@` 檔案引用是 Gemini CLI 對於開發人員來說最強大的功能之一。它消除了歧義——您不是要求模型依賴記憶或猜測檔案，而是直接將檔案交給它閱讀。您可以將其用於原始碼、文字文件、日誌等。同樣，您可以引用整個目錄：

```
重構 @./utils/ 中的程式碼以使用 async/await。
```

透過附加以斜線結尾的路徑，Gemini CLI 將遞歸地包含該目錄中的檔案（在合理範圍內，尊重忽略檔案和大小限制）。這對於多檔案重構或分析非常有用，因為 AI 可以同時考慮所有相關模組。

更令人印象深刻的是，您可以在提示中引用圖像等二進位檔案。Gemini CLI（使用 Gemini 模型的多模態功能）可以理解圖像。例如：

```
描述您在此螢幕截圖中看到的內容：@./design/mockup.png
```

圖像將被輸入到模型中，AI 可能會回應類似「這是一個帶有藍色登入按鈕和標題圖像的登入頁面」等內容。您可以想像其用途：審查 UI 模型、組織照片（我們將在稍後的技巧中看到），或從圖像中提取文字（Gemini 也可以執行 OCR）。

**關於有效使用 @ 引用的幾點說明：**

*   **檔案限制：** Gemini 2.5 Pro 具有巨大的上下文視窗（最多 100 萬個 token），因此您可以包含相當大的檔案或許多檔案。但是，極大的檔案可能會被截斷。如果檔案非常大（例如，數十萬行），請考慮總結它或將其分解為多個部分。如果引用太大或由於大小而跳過某些內容，Gemini CLI 將會警告您。
*   **自動忽略：** 預設情況下，Gemini CLI 在提取目錄上下文時會尊重您的 `.gitignore` 和 `.geminiignore` 檔案。因此，如果您 `@./` 專案根目錄，它不會將巨大的被忽略資料夾（例如 `node_modules`）轉儲到提示中。您可以像 `.gitignore` 一樣使用 `.geminiignore` 自訂忽略模式。
*   **顯式與隱式上下文：** Taylor Mullen（Gemini CLI 的創建者）強調使用 `@` 進行顯式上下文注入，而不是依賴模型的記憶或自己總結事物。它更精確，並確保 AI 不會產生內容幻覺。盡可能將 AI 指向真相來源（程式碼、設定檔、文件）與 `@` 引用。這種做法可以顯著提高準確性。
*   **鏈接引用：** 您可以在一個提示中包含多個檔案，例如：

    ```
    比較 @./foo.py 和 @./bar.py 並告訴我差異。
    ```

    CLI 將包含這兩個檔案。請注意 token 限制；多個大檔案可能會消耗大量的上下文視窗。

使用 `@` 本質上是您即時將知識輸入 Gemini CLI 的方式。它將 CLI 轉變為一個可以處理文字和圖像的多模態閱讀器。作為專業用戶，請養成利用這一點的習慣——它通常比詢問 AI 諸如「開啟檔案 X 並執行 Y」（它可能不會自己執行）之類的問題更快、更可靠。相反，您明確地將 X 交給它處理。

## 技巧 8：即時工具建立（讓 GEMINI 建立輔助工具）

**快速用例：** 如果手頭的任務需要一個小型腳本或實用程式，您可以要求 Gemini CLI 在您的會話中為您建立該工具。例如，您可能會說：「編寫一個 Python 腳本來解析此資料夾中的所有 JSON 檔案並提取錯誤欄位。」Gemini 可以生成該腳本，然後您可以透過 CLI 執行它。本質上，您可以隨時動態擴展工具集。

Gemini CLI 不僅限於其預先存在的工具；它可以在需要時利用其編碼能力來製造新工具。這通常是隱式發生的：如果您要求複雜的事情，AI 可能會建議編寫一個臨時檔案（帶有程式碼）然後運行它。作為用戶，您也可以明確地指導這個過程：

*   **建立腳本：** 您可以提示 Gemini 以您選擇的語言建立腳本或程式。它可能會使用 `write_file` 工具來建立檔案。例如：

    ```
    生成一個 Node.js 腳本，讀取目前目錄中的所有「.log」檔案並報告每個檔案中的行數。
    ```

    Gemini CLI 將起草程式碼，並在您批准後將其寫入檔案（例如 `script.js`）。然後您可以透過使用 `!` shell 命令（例如 `!node script.js`）或要求 Gemini CLI 執行它來運行它（如果 AI 認為它是計畫的一部分，它可能會自動使用 `run_shell_command` 來執行它剛剛編寫的腳本）。
*   **透過 MCP 建立臨時工具：** 在高級場景中，AI 甚至可能建議啟動 MCP 伺服器以執行某些專門任務。例如，如果您的提示涉及一些繁重的文字處理，而這些處理可能更適合用 Python 完成，Gemini 可以生成一個簡單的 Python MCP 伺服器並運行它。雖然這種情況較為罕見，但它表明 AI 可以即時設定一個新的「代理」。 （Gemini CLI 團隊的一張投影片幽默地提到「MCP 伺服器適用於所有事物，甚至有一個名為 LROwn 的」——暗示您可以讓 Gemini 運行自己的實例或其他模型，儘管這更像是一個技巧而不是實際用途！）。

這裡的關鍵好處是自動化。您無需手動停止編寫輔助腳本，您可以讓 AI 將其作為流程的一部分來完成。這就像有一個可以按需建立工具的助理。這對於資料轉換任務、批次操作或內建工具不直接提供的一次性計算特別有用。

**細微差別和安全性：** 當 Gemini CLI 為新工具編寫程式碼時，您仍然應該在運行之前審查它。`/diff` 視圖（Gemini 會在您批准寫入之前向您顯示檔案差異）是您檢查程式碼的機會。確保它執行您期望的操作，並且沒有惡意或破壞性（除非您的提示明確要求，否則 AI 不應產生有害內容，但就像任何來自 AI 的程式碼一樣，請仔細檢查邏輯，特別是對於刪除或修改大量資料的腳本）。

**範例場景：** 假設您有一個 CSV 檔案，並且您想以複雜的方式篩選它。您要求 Gemini CLI 執行此操作，它可能會說：「我將編寫一個 Python 腳本來解析 CSV 並應用篩選器。」然後它會建立 `filter_data.py`。在您批准並運行後，您會得到結果，並且您可能再也不需要該腳本了。這種工具的臨時建立是一個專業舉動——它顯示 AI 有效地自主擴展其功能。

**專業技巧：** 如果您發現該腳本在即時上下文之外也很有用，您可以將其提升為永久工具或命令。例如，如果 AI 生成了一個很棒的日誌處理腳本，您以後可能會將其轉變為自訂斜線命令（技巧 #2）以便於重複使用。Gemini 的生成能力和擴展掛鉤的結合意味著您的工具包可以隨著您使用 CLI 而不斷發展。

總之，不要將 Gemini 限制在其附帶的功能。將其視為一個初級開發人員，他可以快速編寫新程式甚至迷你伺服器來幫助解決問題。這種方法體現了 Gemini CLI 的代理哲學——它會找出它需要的工具，即使它必須即時編寫它們。
